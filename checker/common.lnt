module common is

-- We define a simple programming language with the following instruction:
-- ATOMIC_EXCH_BRANCH(check_loc, exch_val, do_exch, check_val, branch_target, do_branch)

-------------------------------------------------------------------------------
-- Types, Channels

type NatSet is
  set of nat
  with "length", "remove", "member"
end type

-- Shared memory
function NumMemLoc() : nat is
  return 1
end function

type MemArray is
  array [1..1] of int
end type

type MemLoc is
  range 1..1 of nat
end type

type Instruction is
  ATOMIC_EXCH_BRANCH(check_loc: MemLoc, exch_val: int, do_exch: bool, check_val: int, branch_target: nat, do_branch: bool)
   with "get"
end type

type Program is
   list of Instruction
   with "access", "length"
end type

-- A channel is a way to type the interactions between processes

channel NatChan is
  (nat)
end channel

channel ExChan is
  -- tid, instruction, do_branch
  (nat, Instruction, NatSet)
end channel

-------------------------------------------------------------------------------
-- Processes

-- This process is an interpretor for our simple programming language
-- It makes actions on gate "EX" (EXecute) to both show which instruction it
-- executes, and to synchronize with the "Memory" process defined below.
-- Arguments are: Thread id, Program to execute
-- ('select A [] B end select' is the non-deterministic choice between actions)
process Thread [EX: ExChan, TERMINATE: NatChan] (tid: nat, prog: Program) is
  var
    pc: nat, -- program counter
    -- variables to match ATOMIC_EXCH_BRANCH_MEM arguments:
    check_loc: MemLoc, exch_val: int, do_exch: bool, check_val: int, branch_target: nat
 in
    pc := 1; -- start at first instruction (list indexes start at 1)

    loop execute_loop in

      case access(prog, pc) of Instruction in
         ATOMIC_EXCH_BRANCH(check_loc, exch_val, do_exch, check_val, branch_target, any bool) ->
            select
               EX(tid, ATOMIC_EXCH_BRANCH(check_loc, exch_val, do_exch, check_val, branch_target, true), ?any NatSet);
               pc := branch_target
            []
               EX(tid, ATOMIC_EXCH_BRANCH(check_loc, exch_val, do_exch, check_val, branch_target, false), ?any NatSet);
               pc := pc + 1
            end select
      end case;

      -- Reach end of program?
      if pc > length(prog) then
        break execute_loop
      end if

    end loop;
    -- signal end of thread to scheduler
    TERMINATE(tid)
  end var
end process

-- This process specifies the behavior of the shared memory
-- The gate "EX" (EXecute) is used to synchronize with other processes, which represent threads
process SHARED_MEMORY [EX: ExChan, TERMINATE: NatChan, ALL_DONE: none] (numThread: nat) is
  var
    doneThread: nat,
    mem: MemArray,
    -- variables to match ATOMIC_EXCH_BRANCH_MEM arguments:
    check_loc: MemLoc, exch_val: int, do_exch: bool, check_val: int, do_branch: bool
  in
    doneThread := 0;
    mem := MemArray(0);

    -- main loop
    loop mem_loop in
      select
        EX(?any nat, ?ATOMIC_EXCH_BRANCH(check_loc, exch_val, do_exch, check_val, any nat, do_branch), ?any NatSet) where do_branch == (check_val == mem[nat(check_loc)]);
        if do_exch then
          mem[nat(check_loc)] := exch_val
        end if

      []

        TERMINATE(?any nat);
        doneThread := doneThread + 1;
        if doneThread == numThread then
          break mem_loop
        end if
      end select
    end loop;

    ALL_DONE

  end var
end process

-- This process specifies a "no scheduler", which always allows any process to execute
process SCHEDULER_NONE [EX: ExChan, TERMINATE: NatChan] (allThreads: NatSet) is
  loop
    select
      EX(?any nat, ?any Instruction, allThreads)
    []
      TERMINATE(?any nat)
    end select
  end loop
end process

-- This process specifies the scheduler for Occupancy Bound Execution model,
-- where a thread is fairly scheduled if it has performed at least one operation
process SCHEDULER_OBE [EX: ExChan, TERMINATE: NatChan] is
  var
    tid: nat,
    fair: NatSet
  in
    fair := {};
    loop
      select
	EX(?tid, ?any Instruction, fair);
        fair := insert(tid, fair)
      []
        TERMINATE(?tid);
	fair := remove(tid, fair)
      end select
    end loop
  end var
end process


-- This process specifies the scheduler for the Heterogeneous System
-- Architecture model, where threads are fairly scheduled based on
-- their id, in a round-robin fashion starting a index 0 and
-- increasing by 1 every time the active thread terminates.
process SCHEDULER_HSA [EX: ExChan, TERMINATE: NatChan] is
  var
    tid: nat,
    fair: nat,
    done: NatSet
  in
    fair := 0;
    done := {};
    loop
      select
        -- Only the active thread is guaranteed fair scheduling
	EX(?any nat, ?any Instruction, {fair})
      []

        -- When activeThread terminates, provide fair scheduling to the next thread id
        TERMINATE(?tid);
        done := insert(tid, done);
        while member(fair, done) loop
          fair := fair + 1
        end loop

      end select
    end loop
  end var
end process


-- This process specifies the scheduler for the HSA+OBE model, which
-- combines HSA and OBE behaviours.
process SCHEDULER_HSA_OBE [EX: ExChan, TERMINATE: NatChan] is
  var
    tid: nat,
    fair: NatSet,
    done: NatSet,
    hsaThread: nat
  in
    hsaThread := 0;
    fair := {hsaThread};
    done := {};

    -- This is OBE behaviour, with the thread corresponding to HSA index being always present in activeThreads

    loop
      select

        -- First execution step of a thread
	EX(?tid, ?any Instruction, fair);
        fair := insert(tid, fair)

      []

        -- Termination of a thread
        TERMINATE(?tid);
        fair := remove(tid, fair);
        done := insert(tid, done);
        while member(hsaThread, done) loop
          hsaThread := hsaThread + 1
        end loop

      end select
    end loop
  end var
end process

-- This process specifies the scheduler for the Linear OBE model,
-- where threads are guaranteed fair scheduling as soon as any thread
-- ID greater or equal to theirs has made a first execution step.
process SCHEDULER_LOBE [EX: ExChan, TERMINATE: NatChan] is
  var
    fair: NatSet,
    done: NatSet,
    tid: nat,
    i: nat
  in
    fair := {};
    done := {};

    loop
      select

        -- any Thread up to highestID is guaranteed fairly scheduling
        EX(?tid, ?any Instruction, fair);
        for i := 0 while i <= tid by i := i + 1 loop
          if not(member(i, done)) then
            fair := insert(i, fair)
          end if
        end loop

      []

        -- Termination of a thread
        TERMINATE(?tid);
        fair := remove(tid, fair);
        done := insert(tid, done)

      end select
    end loop
  end var
end process

end module
